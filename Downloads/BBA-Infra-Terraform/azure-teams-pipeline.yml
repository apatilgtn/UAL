# Azure DevOps Pipeline Template for Team Infrastructure Deployments
# This template contains stages for deploying team-specific infrastructure
# Used by: BBA-Infra-Teams/azure-pipelines.yml
#
# NOTE: This is a template file. Template files can only contain:
#   - parameters
#   - stages
# Variables, triggers, and resources must be defined in the calling pipeline.

parameters:
  - name: teamName
    displayName: 'Team Name'
    type: string
    default: 'lending'
  - name: projectName
    displayName: 'Project Name'
    type: string
    default: 'loan-origination'
  - name: environment
    displayName: 'Environment'
    type: string
    default: 'dev'
    values:
      - dev
      - test
      - uat
      - prod

stages:
- stage: Initialize
  displayName: 'Initialize & Validate'
  jobs:
  - job: TerraformInit
    displayName: 'Terraform Initialize'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
    - checkout: BBA-Infra-Terraform
    
    - script: |
        curl -fsSL https://releases.hashicorp.com/terraform/1.13.3/terraform_1.13.3_linux_amd64.zip -o terraform.zip
        unzip terraform.zip
        sudo mv terraform /usr/local/bin/
        terraform version
      displayName: 'Install Terraform'
    
    - script: |
        echo "Configuring Git authentication for Azure DevOps..."
        git config --global url."https://$(System.AccessToken)@dev.azure.com/".insteadOf "https://dev.azure.com/"
        echo "Git authentication configured successfully"
      displayName: 'Configure Git Authentication'
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    
    - script: |
        echo "=== DEBUG: Directory Structure ==="
        echo "Current working directory: $(pwd)"
        echo "System.DefaultWorkingDirectory: $(System.DefaultWorkingDirectory)"
        echo "deploymentPath: $(deploymentPath)"
        echo ""
        echo "Contents of working directory:"
        ls -la $(System.DefaultWorkingDirectory)
        echo ""
        echo "Looking for BBA-Infra-Terraform (all variations):"
        find $(System.DefaultWorkingDirectory) -type d \( -name "BBA-Infra-Terraform" -o -name "BBA-Infra-terraform" -o -name "*Infra*Terraform*" \) 2>/dev/null || echo "Not found"
        echo ""
        echo "Listing all directories in System.DefaultWorkingDirectory:"
        ls -d $(System.DefaultWorkingDirectory)/* 2>/dev/null || echo "Cannot list"
        echo ""
        echo "Contents of deployment path:"
        ls -la $(deploymentPath) 2>/dev/null || echo "Deployment path not found"
        echo ""
        echo "=== Setting module path environment variable ==="
        # Find the actual BBA-Infra-Terraform directory
        TERRAFORM_MODULE_DIR=$(find $(System.DefaultWorkingDirectory) -type d -name "*Infra*Terraform*" -o -name "*Infra*terraform*" 2>/dev/null | head -1)
        if [ -z "$TERRAFORM_MODULE_DIR" ]; then
          # Try common variations
          for dir in "BBA-Infra-Terraform" "BBA-Infra-terraform" "s"; do
            if [ -d "$(System.DefaultWorkingDirectory)/$dir" ]; then
              TERRAFORM_MODULE_DIR="$(System.DefaultWorkingDirectory)/$dir"
              break
            fi
          done
        fi
        if [ -z "$TERRAFORM_MODULE_DIR" ]; then
          echo "ERROR: Could not find BBA-Infra-Terraform directory"
          exit 1
        fi
        echo "Found module directory: $TERRAFORM_MODULE_DIR"
        echo "##vso[task.setvariable variable=TERRAFORM_MODULE_PATH]$TERRAFORM_MODULE_DIR/modules/azure-application-platform"
        echo "Module path set to: $TERRAFORM_MODULE_DIR/modules/azure-application-platform"
        echo "=== END DEBUG ==="
      displayName: 'Debug Directory Structure & Set Module Path'
    
    - task: AzureCLI@2
      displayName: 'Terraform Init'
      inputs:
        azureSubscription: 'sc-terraform-${{ parameters.environment }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        addSpnToEnvironment: true
        inlineScript: |
          echo "Initializing Terraform for ${{ parameters.teamName }}/${{ parameters.projectName }}/${{ parameters.environment }}"
          cd $(deploymentPath)
          
          # Initialize Terraform - fail on error
          echo "Running terraform init..."
          if ! terraform init; then
            echo "❌ Terraform init failed"
            
            # Log terraform init failure to Application Insights
            echo "Logging terraform init failure to Application Insights..."
            
            # Create JSON payload for terraform init failure using printf
            printf '{
              "time": "%s",
              "iKey": "%s",
              "name": "Microsoft.ApplicationInsights.Message",
              "tags": {
                "ai.cloud.roleInstance": "%s",
                "ai.operation.id": "%s",
                "ai.operation.name": "Terraform Init Failure"
              },
              "data": {
                "baseType": "MessageData",
                "baseData": {
                  "ver": 2,
                  "message": "Terraform initialization failed during infrastructure planning",
                  "severityLevel": "Error",
                  "properties": {
                    "team": "%s",
                    "project": "%s",
                    "environment": "%s",
                    "stage": "Plan",
                    "operation": "terraform init",
                    "buildId": "%s",
                    "buildNumber": "%s",
                    "sourceBranch": "%s",
                    "sourceVersion": "%s",
                    "agentName": "%s",
                    "deploymentPath": "%s",
                    "errorType": "TerraformInitFailure",
                    "timestamp": "%s"
                  }
                }
              }
            }' \
            "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
            "$(INSTRUMENTATION_KEY)" \
            "$(Agent.MachineName)" \
            "$(Build.BuildId)" \
            "${{ parameters.teamName }}" \
            "${{ parameters.projectName }}" \
            "${{ parameters.environment }}" \
            "$(Build.BuildId)" \
            "$(Build.BuildNumber)" \
            "$(Build.SourceBranch)" \
            "$(Build.SourceVersion)" \
            "$(Agent.Name)" \
            "$(deploymentPath)" \
            "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > terraform_init_failure_log.json
            
            # Send log to Application Insights
            curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
              -H "Content-Type: application/json" \
              -d @terraform_init_failure_log.json || echo "Failed to send log to Application Insights"
            
            exit 1
          fi
          
          echo "✅ Terraform initialization completed successfully!"

- stage: Validate
  displayName: 'Terraform Validation'
  dependsOn: Initialize
  jobs:
  - job: TerraformValidate
    displayName: 'Validate Configuration'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        curl -fsSL https://releases.hashicorp.com/terraform/1.13.3/terraform_1.13.3_linux_amd64.zip -o terraform.zip
        unzip terraform.zip
        sudo mv terraform /usr/local/bin/
        terraform version
      displayName: 'Install Terraform'
    
    - task: AzureCLI@2
      displayName: 'Terraform Validate'
      inputs:
        azureSubscription: 'sc-terraform-${{ parameters.environment }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        addSpnToEnvironment: true
        inlineScript: |
          echo "Validating Terraform configuration for ${{ parameters.teamName }}/${{ parameters.projectName }}/${{ parameters.environment }}"
          cd $(deploymentPath)
          
          # Initialize (needed for validation) - fail on error
          echo "Running terraform init..."
          if ! terraform init; then
            echo "❌ Terraform init failed"
            exit 1
          fi
          
          # Validate configuration - fail on error
          echo "Running terraform validate..."
          if ! terraform validate; then
            echo "❌ Terraform validation failed"
            exit 1
          fi
          
          # Format check - fail on error
          echo "Running terraform format check..."
          if ! terraform fmt -check=true; then
            echo "❌ Terraform format check failed - please run 'terraform fmt'"
            exit 1
          fi
          
          echo "✅ Terraform validation completed successfully!"

- stage: Format
  displayName: 'Terraform Format & Auto-Fix'
  jobs:
  - job: TerraformFormat
    displayName: 'Format Terraform Files'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
      persistCredentials: true
    - checkout: BBA-Infra-Terraform
    
    - script: |
        curl -fsSL https://releases.hashicorp.com/terraform/1.13.3/terraform_1.13.3_linux_amd64.zip -o terraform.zip
        unzip terraform.zip
        sudo mv terraform /usr/local/bin/
        terraform version
      displayName: 'Install Terraform'
    
    - task: AzureCLI@2
      displayName: 'Terraform Format & Commit'
      inputs:
        azureSubscription: 'sc-terraform-${{ parameters.environment }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        addSpnToEnvironment: true
        inlineScript: |
          echo "Formatting Terraform files for ${{ parameters.teamName }}/${{ parameters.projectName }}/${{ parameters.environment }}"
          cd $(deploymentPath)
          
          # Initialize (needed for formatting)
          echo "Running terraform init..."
          terraform init
          
          # Format the code
          echo "Running terraform fmt..."
          terraform fmt -recursive
          
          # Check if any files were changed
          if git diff --quiet; then
            echo "✅ No formatting changes needed"
          else
            echo "📝 Formatting changes detected, committing..."
            
            # Configure git
            git config user.name "Azure DevOps Pipeline"
            git config user.email "pipeline@beyondbank.com.au"
            
            # Add and commit changes
            git add .
            git commit -m "style: Auto-format Terraform files via pipeline
            
            - Automatically formatted ${{ parameters.teamName }}/${{ parameters.projectName }}/${{ parameters.environment }}
            - Ensures consistent code style across team configurations
            - Triggered by Azure DevOps pipeline"
            
            # Push changes back to repository
            git push origin main
            
            echo "✅ Formatting changes committed and pushed"
          fi
          
          echo "✅ Terraform formatting completed successfully!"

# TEMPORARY_FIX_STATE stage - COMMENTED OUT (No longer needed)
# This stage was used to remove ghost resources from state for UAT environment.
# The pre-plan ghost cleanup in ResourceImport stage now handles this automatically.
# If needed in the future, uncomment this stage.
#
# - stage: TEMPORARY_FIX_STATE
#   displayName: 'TEMP FIX: Remove Ghost Resources from State'
#   condition: and(succeeded(), eq('${{ parameters.environment }}', 'uat'))
#   dependsOn: Format
#   jobs:
#     - job: StateCleanup
#       displayName: 'Remove Ghost State Entries'
#       pool:
#         vmImage: 'ubuntu-latest'
#       steps:
#         - checkout: self
#         - checkout: BBA-Infra-Terraform
#         - task: AzureCLI@2
#           displayName: 'Install Terraform and Remove Ghost State'
#           inputs:
#             azureSubscription: 'sc-terraform-${{ parameters.environment }}'
#             scriptType: 'bash'
#             scriptLocation: 'inlineScript'
#             addSpnToEnvironment: true
#             inlineScript: |
#               curl -fsSL https://releases.hashicorp.com/terraform/1.13.3/terraform_1.13.3_linux_amd64.zip -o terraform.zip
#               unzip terraform.zip
#               sudo mv terraform /usr/local/bin/
#               terraform version
#
#               cd $(deploymentPath)
#               echo "Running terraform init to get state access"
#               terraform init -input=false
#               
#               # Set up Azure subscription context
#               export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
#               RG_NAME="rg-${{ parameters.teamName }}-${{ parameters.projectName }}-${{ parameters.environment }}"
#               
#               echo "Listing resources in state before cleanup:"
#               terraform state list || true
#               
#               # Only remove from state if resource doesn't exist in Azure
#               echo "Checking if Storage Account exists in Azure..."
#               STORAGE_SA="module.loan_origination_uat.azurerm_storage_account.main[0]"
#               if terraform state show "$STORAGE_SA" >/dev/null 2>&1; then
#                 # Try multiple methods to extract storage account name
#                 STORAGE_STATE=$(terraform state show "$STORAGE_SA" 2>/dev/null || echo "")
#                 STORAGE_NAME=$(echo "$STORAGE_STATE" | grep -E '^\s+name\s+=' | head -1 | sed 's/.*= *"\([^"]*\)".*/\1/' || echo "")
#                 if [ -z "$STORAGE_NAME" ]; then
#                   # Fallback: try to get from state JSON
#                   STORAGE_NAME=$(terraform state show -json "$STORAGE_SA" 2>/dev/null | grep -oP '"name":\s*"\K[^"]+' | head -1 || echo "")
#                 fi
#                 
#                 if [ -n "$STORAGE_NAME" ]; then
#                   echo "Found Storage Account in state: $STORAGE_NAME"
#                   if ! az storage account show --name "$STORAGE_NAME" --resource-group "$RG_NAME" >/dev/null 2>&1; then
#                     echo "⚠️  Storage Account $STORAGE_NAME NOT found in Azure - removing ghost from state"
#                     terraform state rm "$STORAGE_SA" || true
#                   else
#                     echo "✅ Storage Account $STORAGE_NAME exists in Azure - keeping in state"
#                   fi
#                 else
#                   echo "⚠️  Could not extract Storage Account name from state - attempting unconditional removal"
#                   terraform state rm "$STORAGE_SA" || true
#                 fi
#               else
#                 echo "ℹ️  Storage Account not in state - nothing to clean"
#               fi
#               
#               echo "Checking if Key Vault exists in Azure..."
#               KV_SA="module.loan_origination_uat.azurerm_key_vault.main[0]"
#               if terraform state show "$KV_SA" >/dev/null 2>&1; then
#                 # Try multiple methods to extract key vault name
#                 KV_STATE=$(terraform state show "$KV_SA" 2>/dev/null || echo "")
#                 KV_NAME=$(echo "$KV_STATE" | grep -E '^\s+name\s+=' | head -1 | sed 's/.*= *"\([^"]*\)".*/\1/' || echo "")
#                 if [ -z "$KV_NAME" ]; then
#                   # Fallback: try to get from state JSON
#                   KV_NAME=$(terraform state show -json "$KV_SA" 2>/dev/null | grep -oP '"name":\s*"\K[^"]+' | head -1 || echo "")
#                 fi
#                 
#                 if [ -n "$KV_NAME" ]; then
#                   echo "Found Key Vault in state: $KV_NAME"
#                   if ! az keyvault show --name "$KV_NAME" --resource-group "$RG_NAME" >/dev/null 2>&1; then
#                     echo "⚠️  Key Vault $KV_NAME NOT found in Azure - removing ghost from state"
#                     terraform state rm "$KV_SA" || true
#                   else
#                     echo "✅ Key Vault $KV_NAME exists in Azure - keeping in state"
#                   fi
#                 else
#                   echo "⚠️  Could not extract Key Vault name from state - attempting unconditional removal"
#                   terraform state rm "$KV_SA" || true
#                 fi
#               else
#                 echo "ℹ️  Key Vault not in state - nothing to clean"
#               fi
#               
#               echo ""
#               echo "Listing resources in state after cleanup:"
#               terraform state list || true

- stage: Plan
  displayName: 'Terraform Plan & Cost Estimation'
  dependsOn:
    - Format
  condition: succeeded()
  jobs:
  - job: TerraformPlan
    displayName: 'Plan Infrastructure'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
    - checkout: BBA-Infra-Terraform
    - script: |
        curl -fsSL https://releases.hashicorp.com/terraform/1.13.3/terraform_1.13.3_linux_amd64.zip -o terraform.zip
        unzip terraform.zip
        sudo mv terraform /usr/local/bin/
        terraform version
      displayName: 'Install Terraform'
    
    - task: AzureCLI@2
      displayName: 'Terraform Plan'
      inputs:
        azureSubscription: 'sc-terraform-${{ parameters.environment }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        addSpnToEnvironment: true
        inlineScript: |
          echo "Planning deployment for ${{ parameters.teamName }}/${{ parameters.projectName }}/${{ parameters.environment }}"
          
          # Set up Azure subscription context for Terraform
          echo "Setting up Azure subscription context..."
          export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
          export ARM_CLIENT_ID=$servicePrincipalId
          export ARM_CLIENT_SECRET=$servicePrincipalKey
          export ARM_TENANT_ID=$tenantId
          echo "Using subscription: $ARM_SUBSCRIPTION_ID"
          
          cd $(deploymentPath)
          
          # Initialize Terraform - fail on error
          echo "Running terraform init..."
          if ! terraform init; then
            echo "❌ Terraform init failed"
            
            # Log terraform init failure to Application Insights
            echo "Logging terraform init failure to Application Insights..."
            
            # Create JSON payload for terraform init failure using printf
            printf '{
              "time": "%s",
              "iKey": "%s",
              "name": "Microsoft.ApplicationInsights.Message",
              "tags": {
                "ai.cloud.roleInstance": "%s",
                "ai.operation.id": "%s",
                "ai.operation.name": "Terraform Init Failure"
              },
              "data": {
                "baseType": "MessageData",
                "baseData": {
                  "ver": 2,
                  "message": "Terraform initialization failed during infrastructure planning",
                  "severityLevel": "Error",
                  "properties": {
                    "team": "%s",
                    "project": "%s",
                    "environment": "%s",
                    "stage": "Plan",
                    "operation": "terraform init",
                    "buildId": "%s",
                    "buildNumber": "%s",
                    "sourceBranch": "%s",
                    "sourceVersion": "%s",
                    "agentName": "%s",
                    "deploymentPath": "%s",
                    "errorType": "TerraformInitFailure",
                    "timestamp": "%s"
                  }
                }
              }
            }' \
            "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
            "$(INSTRUMENTATION_KEY)" \
            "$(Agent.MachineName)" \
            "$(Build.BuildId)" \
            "${{ parameters.teamName }}" \
            "${{ parameters.projectName }}" \
            "${{ parameters.environment }}" \
            "$(Build.BuildId)" \
            "$(Build.BuildNumber)" \
            "$(Build.SourceBranch)" \
            "$(Build.SourceVersion)" \
            "$(Agent.Name)" \
            "$(deploymentPath)" \
            "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > terraform_init_failure_log.json
            
            # Send log to Application Insights
            curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
              -H "Content-Type: application/json" \
              -d @terraform_init_failure_log.json || echo "Failed to send log to Application Insights"
            
            exit 1
          fi
          
          # Create plan - fail on error
          echo "Running terraform plan..."
          echo "Creating fresh Terraform plan..."
          if ! terraform plan -out=tfplan; then
            echo "❌ Terraform plan failed"
            
            # Log terraform plan failure to Application Insights
            echo "Logging terraform plan failure to Application Insights..."
            
            # Create JSON payload for terraform plan failure using printf
            printf '{
              "time": "%s",
              "iKey": "%s",
              "name": "Microsoft.ApplicationInsights.Message",
              "tags": {
                "ai.cloud.roleInstance": "%s",
                "ai.operation.id": "%s",
                "ai.operation.name": "Terraform Plan Failure"
              },
              "data": {
                "baseType": "MessageData",
                "baseData": {
                  "ver": 2,
                  "message": "Terraform plan generation failed during infrastructure planning",
                  "severityLevel": "Error",
                  "properties": {
                    "team": "%s",
                    "project": "%s",
                    "environment": "%s",
                    "stage": "Plan",
                    "operation": "terraform plan",
                    "buildId": "%s",
                    "buildNumber": "%s",
                    "sourceBranch": "%s",
                    "sourceVersion": "%s",
                    "agentName": "%s",
                    "deploymentPath": "%s",
                    "errorType": "TerraformPlanFailure",
                    "timestamp": "%s"
                  }
                }
              }
            }' \
            "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
            "$(INSTRUMENTATION_KEY)" \
            "$(Agent.MachineName)" \
            "$(Build.BuildId)" \
            "${{ parameters.teamName }}" \
            "${{ parameters.projectName }}" \
            "${{ parameters.environment }}" \
            "$(Build.BuildId)" \
            "$(Build.BuildNumber)" \
            "$(Build.SourceBranch)" \
            "$(Build.SourceVersion)" \
            "$(Agent.Name)" \
            "$(deploymentPath)" \
            "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > terraform_plan_failure_log.json
            
            # Send log to Application Insights
            curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
              -H "Content-Type: application/json" \
              -d @terraform_plan_failure_log.json || echo "Failed to send log to Application Insights"
            
            exit 1
          fi
          
          # Show readable plan with detailed output
          echo "Generating readable plan output..."
          terraform show -no-color tfplan > tfplan-readable.txt
          
          # Extract plan summary counts
          PLAN_OUTPUT=$(terraform show -json tfplan 2>/dev/null)
          if [ -n "$PLAN_OUTPUT" ]; then
            CREATE_COUNT=$(echo "$PLAN_OUTPUT" | jq '[.resource_changes[] | select(.change.actions[] | contains("create") and (contains("delete") | not))] | length' 2>/dev/null || echo "0")
            UPDATE_COUNT=$(echo "$PLAN_OUTPUT" | jq '[.resource_changes[] | select(.change.actions[] | contains("update"))] | length' 2>/dev/null || echo "0")
            DESTROY_COUNT=$(echo "$PLAN_OUTPUT" | jq '[.resource_changes[] | select(.change.actions[] | contains("delete"))] | length' 2>/dev/null || echo "0")
            REPLACE_COUNT=$(echo "$PLAN_OUTPUT" | jq '[.resource_changes[] | select(.change.actions[] | contains("create") and contains("delete"))] | length' 2>/dev/null || echo "0")
            
            # Display beautiful plan summary header
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "                    🎯 TERRAFORM EXECUTION PLAN SUMMARY                        "
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            printf "  📊 Plan Statistics:\n"
            printf "     ┌──────────────────────────────────────────────────────┐\n"
            printf "     │  Action      │ Count │ Status                       │\n"
            printf "     ├──────────────────────────────────────────────────────┤\n"
            if [ "$CREATE_COUNT" -gt 0 ]; then
              printf "     │  ➕ Create    │ %5s │ Ready to deploy              │\n" "$CREATE_COUNT"
            else
              printf "     │  ➕ Create    │     0 │ No new resources            │\n"
            fi
            if [ "$UPDATE_COUNT" -gt 0 ]; then
              printf "     │  🔄 Update    │ %5s │ Ready to modify              │\n" "$UPDATE_COUNT"
            else
              printf "     │  🔄 Update    │     0 │ No updates needed           │\n"
            fi
            if [ "$REPLACE_COUNT" -gt 0 ]; then
              printf "     │  🔃 Replace   │ %5s │ ⚠️  Force replacement          │\n" "$REPLACE_COUNT"
            else
              printf "     │  🔃 Replace   │     0 │ No replacements needed       │\n"
            fi
            if [ "$DESTROY_COUNT" -gt 0 ]; then
              printf "     │  ❌ Destroy   │ %5s │ ⚠️  Will be deleted           │\n" "$DESTROY_COUNT"
            else
              printf "     │  ❌ Destroy   │     0 │ No resources to delete        │\n"
            fi
            printf "     └──────────────────────────────────────────────────────┘\n"
            echo ""
            
            # Display resources in organized tables
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "                    📋 RESOURCE CHANGES DETAIL                                  "
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            
            # Resources to CREATE
            CREATE_RESOURCES=$(echo "$PLAN_OUTPUT" | jq -r '[.resource_changes[] | select(.change.actions[] | contains("create") and (contains("delete") | not))] | if length > 0 then .[] | "\(.type)|\(.name)|\(.address)" else empty end' 2>/dev/null)
            if [ -n "$CREATE_RESOURCES" ] && [ "$CREATE_COUNT" -gt 0 ]; then
              echo "  ➕ RESOURCES TO CREATE ($CREATE_COUNT)"
              echo "  ┌──────────────────────────────────────────────────────────────────────────────────────────────────────┐"
              printf "  │ %-40s │ %-70s │\n" "RESOURCE TYPE" "RESOURCE ADDRESS"
              echo "  ├──────────────────────────────────────────────────────────────────────────────────────────────────────┤"
              echo "$CREATE_RESOURCES" | while IFS='|' read -r type name address; do
                TYPE_SHORT=$(echo "$type" | sed 's/^azurerm_//' | sed 's/_/ /g' | awk '{for(i=1;i<=NF;i++)sub(/./,toupper(substr($i,1,1)),$i)}1')
                printf "  │ %-40s │ %-70s │\n" "$TYPE_SHORT" "$address"
              done
              echo "  └──────────────────────────────────────────────────────────────────────────────────────────────────────┘"
              echo ""
            fi
            
            # Resources to UPDATE
            UPDATE_RESOURCES=$(echo "$PLAN_OUTPUT" | jq -r '[.resource_changes[] | select(.change.actions[] | contains("update") and (contains("delete") | not) and (contains("create") | not))] | if length > 0 then .[] | "\(.type)|\(.name)|\(.address)" else empty end' 2>/dev/null)
            if [ -n "$UPDATE_RESOURCES" ] && [ "$UPDATE_COUNT" -gt 0 ]; then
              echo "  🔄 RESOURCES TO UPDATE ($UPDATE_COUNT)"
              echo "  ┌──────────────────────────────────────────────────────────────────────────────────────────────────────┐"
              printf "  │ %-40s │ %-70s │\n" "RESOURCE TYPE" "RESOURCE ADDRESS"
              echo "  ├──────────────────────────────────────────────────────────────────────────────────────────────────────┤"
              echo "$UPDATE_RESOURCES" | while IFS='|' read -r type name address; do
                TYPE_SHORT=$(echo "$type" | sed 's/^azurerm_//' | sed 's/_/ /g' | awk '{for(i=1;i<=NF;i++)sub(/./,toupper(substr($i,1,1)),$i)}1')
                printf "  │ %-40s │ %-70s │\n" "$TYPE_SHORT" "$address"
              done
              echo "  └──────────────────────────────────────────────────────────────────────────────────────────────────────┘"
              echo ""
            fi
            
            # Resources to REPLACE
            REPLACE_RESOURCES=$(echo "$PLAN_OUTPUT" | jq -r '[.resource_changes[] | select(.change.actions[] | contains("create") and contains("delete"))] | if length > 0 then .[] | "\(.type)|\(.name)|\(.address)" else empty end' 2>/dev/null)
            if [ -n "$REPLACE_RESOURCES" ] && [ "$REPLACE_COUNT" -gt 0 ]; then
              echo "  🔃 RESOURCES TO REPLACE ($REPLACE_COUNT) ⚠️"
              echo "  ┌──────────────────────────────────────────────────────────────────────────────────────────────────────┐"
              printf "  │ %-40s │ %-70s │\n" "RESOURCE TYPE" "RESOURCE ADDRESS"
              echo "  ├──────────────────────────────────────────────────────────────────────────────────────────────────────┤"
              echo "$REPLACE_RESOURCES" | while IFS='|' read -r type name address; do
                TYPE_SHORT=$(echo "$type" | sed 's/^azurerm_//' | sed 's/_/ /g' | awk '{for(i=1;i<=NF;i++)sub(/./,toupper(substr($i,1,1)),$i)}1')
                printf "  │ %-40s │ %-70s │\n" "$TYPE_SHORT" "$address"
              done
              echo "  └──────────────────────────────────────────────────────────────────────────────────────────────────────┘"
              echo ""
            fi
            
            # Resources to DESTROY
            DESTROY_RESOURCES=$(echo "$PLAN_OUTPUT" | jq -r '[.resource_changes[] | select(.change.actions[] | contains("delete") and (contains("create") | not))] | if length > 0 then .[] | "\(.type)|\(.name)|\(.address)" else empty end' 2>/dev/null)
            if [ -n "$DESTROY_RESOURCES" ] && [ "$DESTROY_COUNT" -gt 0 ]; then
              echo "  ❌ RESOURCES TO DESTROY ($DESTROY_COUNT) ⚠️"
              echo "  ┌──────────────────────────────────────────────────────────────────────────────────────────────────────┐"
              printf "  │ %-40s │ %-70s │\n" "RESOURCE TYPE" "RESOURCE ADDRESS"
              echo "  ├──────────────────────────────────────────────────────────────────────────────────────────────────────┤"
              echo "$DESTROY_RESOURCES" | while IFS='|' read -r type name address; do
                TYPE_SHORT=$(echo "$type" | sed 's/^azurerm_//' | sed 's/_/ /g' | awk '{for(i=1;i<=NF;i++)sub(/./,toupper(substr($i,1,1)),$i)}1')
                printf "  │ %-40s │ %-70s │\n" "$TYPE_SHORT" "$address"
              done
              echo "  └──────────────────────────────────────────────────────────────────────────────────────────────────────┘"
              echo ""
            fi
            
            # Overall summary
            TOTAL_CHANGES=$((CREATE_COUNT + UPDATE_COUNT + REPLACE_COUNT + DESTROY_COUNT))
            if [ "$TOTAL_CHANGES" -eq 0 ]; then
              echo "  ✅ No changes detected. Infrastructure matches the configuration."
              echo ""
            fi
            
            # Cost estimation section
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "                    💰 ESTIMATED COST IMPACT                                   "
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            
            # Count resources by type for cost estimation
            echo "  Resource Cost Estimates (Monthly):"
            echo "  ┌─────────────────────────────────────┬────────────────────────────────────────────────────────┐"
            printf "  │ %-35s │ %-54s │\n" "RESOURCE TYPE" "ESTIMATED COST"
            echo "  ├─────────────────────────────────────┼────────────────────────────────────────────────────────┤"
            
            STORAGE_COUNT=$(echo "$PLAN_OUTPUT" | jq '[.resource_changes[] | select(.type == "azurerm_storage_account" and (.change.actions[] | contains("create")))] | length' 2>/dev/null || echo "0")
            KV_COUNT=$(echo "$PLAN_OUTPUT" | jq '[.resource_changes[] | select(.type == "azurerm_key_vault" and (.change.actions[] | contains("create")))] | length' 2>/dev/null || echo "0")
            FUNC_COUNT=$(echo "$PLAN_OUTPUT" | jq '[.resource_changes[] | select(.type | test("azurerm_.*function_app")) and (.change.actions[] | contains("create"))] | length' 2>/dev/null || echo "0")
            INSIGHTS_COUNT=$(echo "$PLAN_OUTPUT" | jq '[.resource_changes[] | select(.type == "azurerm_application_insights" and (.change.actions[] | contains("create")))] | length' 2>/dev/null || echo "0")
            SB_COUNT=$(echo "$PLAN_OUTPUT" | jq '[.resource_changes[] | select(.type == "azurerm_servicebus_namespace" and (.change.actions[] | contains("create")))] | length' 2>/dev/null || echo "0")
            LOG_COUNT=$(echo "$PLAN_OUTPUT" | jq '[.resource_changes[] | select(.type == "azurerm_log_analytics_workspace" and (.change.actions[] | contains("create")))] | length' 2>/dev/null || echo "0")
            
            if [ "$STORAGE_COUNT" -gt 0 ]; then
              printf "  │ %-35s │ %-54s │\n" "📊 Storage Account ($STORAGE_COUNT)" "\$10-\$50/month (usage dependent)"
            fi
            if [ "$KV_COUNT" -gt 0 ]; then
              printf "  │ %-35s │ %-54s │\n" "🔑 Key Vault ($KV_COUNT)" "\$1-\$5/month + operations"
            fi
            if [ "$FUNC_COUNT" -gt 0 ]; then
              printf "  │ %-35s │ %-54s │\n" "⚡ Function App ($FUNC_COUNT)" "\$0-\$100/month (consumption plan)"
            fi
            if [ "$INSIGHTS_COUNT" -gt 0 ]; then
              printf "  │ %-35s │ %-54s │\n" "📈 Application Insights ($INSIGHTS_COUNT)" "\$2-\$20/month (data ingestion)"
            fi
            if [ "$SB_COUNT" -gt 0 ]; then
              printf "  │ %-35s │ %-54s │\n" "🚌 Service Bus ($SB_COUNT)" "\$10-\$100/month (standard tier)"
            fi
            if [ "$LOG_COUNT" -gt 0 ]; then
              printf "  │ %-35s │ %-54s │\n" "📋 Log Analytics ($LOG_COUNT)" "\$2-\$50/month (data retention)"
            fi
            
            if [ "$STORAGE_COUNT" -eq 0 ] && [ "$KV_COUNT" -eq 0 ] && [ "$FUNC_COUNT" -eq 0 ] && [ "$INSIGHTS_COUNT" -eq 0 ] && [ "$SB_COUNT" -eq 0 ] && [ "$LOG_COUNT" -eq 0 ]; then
              printf "  │ %-35s │ %-54s │\n" "No new resources" "No additional cost expected"
            fi
            
            echo "  └─────────────────────────────────────┴────────────────────────────────────────────────────────┘"
            echo ""
            echo "  💡 For detailed cost estimation:"
            echo "     • Azure Pricing Calculator: https://azure.microsoft.com/pricing/calculator/"
            echo "     • Review terraform-plan-readable artifact for full details"
            echo "     • Monitor costs in Azure Cost Management after deployment"
            echo ""
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "  ✅ Plan completed successfully! Ready for review and approval."
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
          else
            # Fallback if JSON parsing fails
            echo "=== TERRAFORM PLAN SUMMARY ==="
            terraform show -no-color tfplan | grep -E "Plan:|will be" | head -20
          fi
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Plan'
      inputs:
        targetPath: '$(deploymentPath)/tfplan'
        artifact: 'terraform-plan'
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Readable Plan'
      inputs:
        targetPath: '$(deploymentPath)/tfplan-readable.txt'
        artifact: 'terraform-plan-readable'

- stage: SecurityScan
  displayName: 'Security Scanning'
  dependsOn: Plan
  jobs:
  - job: SecurityScan
    displayName: 'Infrastructure Security Analysis'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
    - checkout: BBA-Infra-Terraform
    - script: |
        curl -fsSL https://releases.hashicorp.com/terraform/1.13.3/terraform_1.13.3_linux_amd64.zip -o terraform.zip
        unzip terraform.zip
        sudo mv terraform /usr/local/bin/
        terraform version
      displayName: 'Install Terraform'
    
    - script: |
        echo "Installing security tools..."
        
        # Install Trivy with error handling
        if ! curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin; then
          echo "❌ Failed to install Trivy security scanner"
          
          # Log Trivy installation failure to Application Insights
          echo "Logging Trivy installation failure to Application Insights..."
          
          # Create JSON payload for Trivy installation failure using printf
          printf '{
            "time": "%s",
            "iKey": "%s",
            "name": "Microsoft.ApplicationInsights.Message",
            "tags": {
              "ai.cloud.roleInstance": "%s",
              "ai.operation.id": "%s",
              "ai.operation.name": "Trivy Install Failure"
            },
            "data": {
              "baseType": "MessageData",
              "baseData": {
                "ver": 2,
                "message": "Failed to install Trivy security scanner",
                "severityLevel": "Error",
                "properties": {
                  "team": "%s",
                  "project": "%s",
                  "environment": "%s",
                  "stage": "SecurityScan",
                  "operation": "trivy install",
                  "buildId": "%s",
                  "buildNumber": "%s",
                  "sourceBranch": "%s",
                  "sourceVersion": "%s",
                  "agentName": "%s",
                  "errorType": "TrivyInstallFailure",
                  "timestamp": "%s"
                }
              }
            }
          }' \
          "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
          "$(INSTRUMENTATION_KEY)" \
          "$(Agent.MachineName)" \
          "$(Build.BuildId)" \
          "${{ parameters.teamName }}" \
          "${{ parameters.projectName }}" \
          "${{ parameters.environment }}" \
          "$(Build.BuildId)" \
          "$(Build.BuildNumber)" \
          "$(Build.SourceBranch)" \
          "$(Build.SourceVersion)" \
          "$(Agent.Name)" \
          "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > trivy_install_failure_log.json
          
          # Send log to Application Insights
          curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
            -H "Content-Type: application/json" \
            -d @trivy_install_failure_log.json || echo "Failed to send log to Application Insights"
          
          exit 1
        fi
        
        # Install TfSec with error handling
        if ! curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash; then
          echo "❌ Failed to install TfSec security scanner"
          
          # Log TfSec installation failure to Application Insights
          echo "Logging TfSec installation failure to Application Insights..."
          
          # Create JSON payload for TfSec installation failure using printf
          printf '{
            "time": "%s",
            "iKey": "%s",
            "name": "Microsoft.ApplicationInsights.Message",
            "tags": {
              "ai.cloud.roleInstance": "%s",
              "ai.operation.id": "%s",
              "ai.operation.name": "TfSec Install Failure"
            },
            "data": {
              "baseType": "MessageData",
              "baseData": {
                "ver": 2,
                "message": "Failed to install TfSec security scanner",
                "severityLevel": "Error",
                "properties": {
                  "team": "%s",
                  "project": "%s",
                  "environment": "%s",
                  "stage": "SecurityScan",
                  "operation": "tfsec install",
                  "buildId": "%s",
                  "buildNumber": "%s",
                  "sourceBranch": "%s",
                  "sourceVersion": "%s",
                  "agentName": "%s",
                  "errorType": "TfSecInstallFailure",
                  "timestamp": "%s"
                }
              }
            }
          }' \
          "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
          "$(INSTRUMENTATION_KEY)" \
          "$(Agent.MachineName)" \
          "$(Build.BuildId)" \
          "${{ parameters.teamName }}" \
          "${{ parameters.projectName }}" \
          "${{ parameters.environment }}" \
          "$(Build.BuildId)" \
          "$(Build.BuildNumber)" \
          "$(Build.SourceBranch)" \
          "$(Build.SourceVersion)" \
          "$(Agent.Name)" \
          "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > tfsec_install_failure_log.json
          
          # Send log to Application Insights
          curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
            -H "Content-Type: application/json" \
            -d @tfsec_install_failure_log.json || echo "Failed to send log to Application Insights"
          
          exit 1
        fi
        
        echo "Verifying tool installations..."
        trivy version
        tfsec version
        echo "Security tools installed successfully"
      displayName: 'Install Security Tools'
    
    - task: AzureCLI@2
      displayName: 'Security Scan'
      inputs:
        azureSubscription: 'sc-terraform-${{ parameters.environment }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        addSpnToEnvironment: true
        inlineScript: |
          echo "========================================================"
          echo "INFRASTRUCTURE SECURITY ANALYSIS"
          echo "========================================================"
          echo "Team: ${{ parameters.teamName }}"
          echo "Project: ${{ parameters.projectName }}"
          echo "Environment: ${{ parameters.environment }}"
          echo "Scan Date: $(date '+%Y-%m-%d %H:%M:%S')"
          echo ""
          
          cd $(deploymentPath)
          
          # Initialize for scanning
          echo "Initializing Terraform for security scanning..."
          terraform init
          echo ""
          
          echo "========================================================"
          echo "TRIVY SECURITY ANALYSIS"
          echo "========================================================"
          echo "Trivy will scan for:"
          echo "   - Infrastructure misconfigurations"
          echo "   - Security vulnerabilities in Terraform code"
          echo "   - Compliance violations"
          echo "   - Best practice deviations"
          echo ""
          echo "Scan Targets:"
          echo "   - Terraform configuration files (*.tf)"
          echo "   - Module dependencies"
          echo "   - Resource configurations"
          echo "   - Variable definitions"
          echo ""
          echo "Severity Levels: CRITICAL, HIGH, MEDIUM"
          echo "Exit Code: FAIL on any findings (--exit-code 1)"
          echo ""
          echo "Starting Trivy scan..."
          echo "--------------------------------------------------------"
          
          # First, let's see what files we have for scanning
          echo "DEBUG: Current directory: $(pwd)"
          echo "DEBUG: Terraform files found:"
          find . -name "*.tf" -type f | head -10
          echo ""
          echo "DEBUG: Removing any old terraform plan files that might interfere with scanning..."
          find . -name "*.tfplan" -type f -delete 2>/dev/null || true
          find . -name "tfplan" -type f -delete 2>/dev/null || true
          echo ""
          
          # Run enhanced Trivy security scan with detailed output
          # Scan only source Terraform files, exclude plan files and state files
          # Generate both table format (for console) and SARIF format (for Scans tab)
          echo "Running: trivy config . --format table --severity CRITICAL,HIGH,MEDIUM --exit-code 1 --skip-files '*.tfplan,*.tfstate,tfplan'"
          echo "Also generating: trivy config . --format sarif --output trivy-results.sarif"
          
          # Store exit code to check results
          set +e  # Don't exit on error immediately
          trivy config . \
            --format table \
            --severity CRITICAL,HIGH,MEDIUM \
            --exit-code 1 \
            --skip-files '*.tfplan,*.tfstate,tfplan' 2>&1 | tee trivy-scan-results.txt
          TRIVY_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Generate SARIF file for Azure DevOps Scans tab
          echo "Generating SARIF format for Scans tab..."
          trivy config . \
            --format sarif \
            --output trivy-results.sarif \
            --severity CRITICAL,HIGH,MEDIUM \
            --skip-files '*.tfplan,*.tfstate,tfplan' || echo "Warning: SARIF generation had issues, but continuing..."
          
          # Check both exit code AND scan content for failures
          TRIVY_FAILURES=$(grep -c "FAILURES:" trivy-scan-results.txt 2>/dev/null || echo 0)
          TRIVY_ISSUES=$(grep -E "(CRITICAL|HIGH|MEDIUM)" trivy-scan-results.txt | grep -v "Tests:" | wc -l || echo 0)
          
          echo "DEBUG: Trivy exit code: $TRIVY_EXIT_CODE"
          echo "DEBUG: Trivy failures found: $TRIVY_FAILURES"
          echo "DEBUG: Trivy security issues: $TRIVY_ISSUES"
          
          if [ $TRIVY_EXIT_CODE -ne 0 ] || [ $TRIVY_FAILURES -gt 0 ] || [ $TRIVY_ISSUES -gt 0 ]; then
            echo ""
            echo "========================================================"
            echo "TRIVY SECURITY SCAN FAILED"
            echo "========================================================"
            echo ""
            echo "Scan Summary:"
            echo "   - Files Scanned: $(find . -name "*.tf" | wc -l) Terraform files"
            echo "   - Modules Analyzed: $(find . -name "main.tf" | wc -l) modules"
            echo "   - Security Issues: DETECTED (Exit: $TRIVY_EXIT_CODE, Failures: $TRIVY_FAILURES, Issues: $TRIVY_ISSUES)"
            echo ""
            echo "Files with Security Findings:"
            grep -o "[^/]*\.tf" trivy-scan-results.txt 2>/dev/null | sort -u | sed 's/^/   - /' || echo "   - Check scan output above"
            echo ""
            echo "Common Issues to Review:"
            echo "   - Key Vault purge protection disabled"
            echo "   - Storage account public access enabled"
            echo "   - Network security groups too permissive"
            echo "   - Function app authentication disabled"
            echo "   - Application insights retention not optimized"
            echo ""
            echo "Remediation Steps:"
            echo "   1. Review the detailed findings above"
            echo "   2. Update Terraform configurations to address issues"
            echo "   3. Test changes in dev environment first"
            echo "   4. Re-run pipeline after fixes"
            echo ""
            echo "DEPLOYMENT BLOCKED - Security issues must be resolved!"
            
            # Log security failure to Application Insights
            echo "Logging security scan failure to Application Insights..."
            
            # Create JSON payload for Application Insights using printf
            printf '{
              "time": "%s",
              "iKey": "%s",
              "name": "Microsoft.ApplicationInsights.Message",
              "tags": {
                "ai.cloud.roleInstance": "%s",
                "ai.operation.id": "%s",
                "ai.operation.name": "Security Scan Failure"
              },
              "data": {
                "baseType": "MessageData",
                "baseData": {
                  "ver": 2,
                  "message": "TRIVY Security Scan Failed - Deployment Blocked",
                  "severityLevel": "Error",
                  "properties": {
                    "PipelineId": "%s",
                    "PipelineName": "%s",
                    "TeamName": "%s",
                    "ProjectName": "%s",
                    "Environment": "%s",
                    "Stage": "SecurityScan",
                    "Tool": "Trivy",
                    "ExitCode": "%s",
                    "FailuresCount": "%s",
                    "IssuesCount": "%s",
                    "FilesScanned": "%s",
                    "ModulesAnalyzed": "%s",
                    "Branch": "%s",
                    "Commit": "%s"
                  }
                }
              }
            }' \
            "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
            "$(INSTRUMENTATION_KEY)" \
            "$(Agent.MachineName)" \
            "$(Build.BuildId)" \
            "$(Build.BuildId)" \
            "$(Build.DefinitionName)" \
            "${{ parameters.teamName }}" \
            "${{ parameters.projectName }}" \
            "${{ parameters.environment }}" \
            "$TRIVY_EXIT_CODE" \
            "$TRIVY_FAILURES" \
            "$TRIVY_ISSUES" \
            "$(find . -name "*.tf" | wc -l)" \
            "$(find . -name "main.tf" | wc -l)" \
            "$(Build.SourceBranch)" \
            "$(Build.SourceVersion)" > security_failure_log.json
            
            # Send to Application Insights
            curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d @security_failure_log.json || echo "Failed to log to Application Insights"
            
            exit 1
          else
            echo ""
            echo "========================================================"
            echo "✅ TRIVY SECURITY SCAN PASSED"
            echo "========================================================"
            echo ""
            echo "Scan Results:"
            echo "   ✅ Trivy Exit Code: $TRIVY_EXIT_CODE"
            echo "   ✅ No CRITICAL, HIGH, or MEDIUM severity issues detected"
            echo ""
            echo "What was scanned:"
            echo "   - Generated terraform plan (security-scan.tfplan)"
            echo "   - Module dependencies and configurations"
            echo ""
            echo "Trivy scan passed - continuing to TfSec..."
            echo ""
          fi
          
          echo ""
          echo "========================================================"
          echo "TFSEC SECURITY ANALYSIS"
          echo "========================================================"
          echo "TfSec will scan for:"
          echo "   - AWS, Azure, GCP security best practices"
          echo "   - Resource-specific security configurations"
          echo "   - Compliance with security standards"
          echo "   - Industry security benchmarks"
          echo ""
          echo "Output Format: SARIF (for Azure DevOps) + Lovely (for console)"
          echo "Minimum Severity: MEDIUM"
          echo "Exit Code: FAIL on any findings"
          echo ""
          echo "Starting TfSec scan..."
          echo "--------------------------------------------------------"
          
          # Run tfsec security scan with SARIF output for Azure DevOps Scans tab
          echo "Running: tfsec . --format sarif --output tfsec-results.sarif"
          
          # Scan and output SARIF format
          set +e  # Don't exit on error immediately
          tfsec . \
            --format sarif \
            --minimum-severity MEDIUM \
            --exit-code 1 2>&1 | tee tfsec-scan-results.txt
          TFSEC_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Check both exit code AND scan content for TfSec failures
          TFSEC_RESULTS=$(grep -c "Result #" tfsec-scan-results.txt 2>/dev/null || echo 0)
          TFSEC_MEDIUM_PLUS=$(grep -E "(MEDIUM|HIGH|CRITICAL)" tfsec-scan-results.txt | grep "Result #" | wc -l || echo 0)
          
          echo "DEBUG: TfSec exit code: $TFSEC_EXIT_CODE"
          echo "DEBUG: TfSec results found: $TFSEC_RESULTS"
          echo "DEBUG: TfSec medium+ issues: $TFSEC_MEDIUM_PLUS"
          
          if [ $TFSEC_EXIT_CODE -ne 0 ] || [ $TFSEC_RESULTS -gt 0 ] || [ $TFSEC_MEDIUM_PLUS -gt 0 ]; then
            echo ""
            echo "========================================================"
            echo "TFSEC SECURITY SCAN FAILED"
            echo "========================================================"
            echo ""
            echo "Security Issues Detected:"
            echo "   - Exit Code: $TFSEC_EXIT_CODE"
            echo "   - Total Results: $TFSEC_RESULTS"
            echo "   - Medium+ Severity: $TFSEC_MEDIUM_PLUS"
            echo ""
            echo "Additional security vulnerabilities detected by TfSec"
            echo "These findings complement the Trivy analysis above"
            echo ""
            echo "TfSec specializes in:"
            echo "   - Cloud provider-specific security rules"
            echo "   - Resource configuration best practices"
            echo "   - Infrastructure compliance checks"
            echo ""
            echo "DEPLOYMENT BLOCKED - All security issues must be resolved!"
            
            # Log TfSec security failure to Application Insights
            echo "Logging TfSec security scan failure to Application Insights..."
            
            # Create JSON payload for Application Insights using printf
            printf '{
              "time": "%s",
              "iKey": "%s",
              "name": "Microsoft.ApplicationInsights.Message",
              "tags": {
                "ai.cloud.roleInstance": "%s",
                "ai.operation.id": "%s",
                "ai.operation.name": "TfSec Security Scan Failure"
              },
              "data": {
                "baseType": "MessageData",
                "baseData": {
                  "ver": 2,
                  "message": "TFSEC Security Scan Failed - Deployment Blocked",
                  "severityLevel": "Error",
                  "properties": {
                    "PipelineId": "%s",
                    "PipelineName": "%s",
                    "TeamName": "%s",
                    "ProjectName": "%s",
                    "Environment": "%s",
                    "Stage": "SecurityScan",
                    "Tool": "TfSec",
                    "ExitCode": "%s",
                    "ResultsCount": "%s",
                    "MediumPlusIssues": "%s",
                    "FilesScanned": "%s",
                    "Branch": "%s",
                    "Commit": "%s"
                  }
                }
              }
            }' \
            "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
            "$(INSTRUMENTATION_KEY)" \
            "$(Agent.MachineName)" \
            "$(Build.BuildId)" \
            "$(Build.BuildId)" \
            "$(Build.DefinitionName)" \
            "${{ parameters.teamName }}" \
            "${{ parameters.projectName }}" \
            "${{ parameters.environment }}" \
            "$TFSEC_EXIT_CODE" \
            "$TFSEC_RESULTS" \
            "$TFSEC_MEDIUM_PLUS" \
            "$(find . -name "*.tf" | wc -l)" \
            "$(Build.SourceBranch)" \
            "$(Build.SourceVersion)" > tfsec_failure_log.json
            
            # Send to Application Insights
            curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d @tfsec_failure_log.json || echo "Failed to log to Application Insights"
            
            exit 1
          else
            echo ""
            echo "========================================================"
            echo "✅ TFSEC SECURITY SCAN PASSED"
            echo "========================================================"
            echo ""
            echo "TfSec scan completed with no security issues detected."
          fi
          
          # Show scan result summary for debugging
          echo ""
          echo "DEBUG: Scan result files created:"
          echo "   - trivy-scan-results.txt ($(wc -l < trivy-scan-results.txt 2>/dev/null || echo 0) lines)"
          echo "   - tfsec-scan-results.txt ($(wc -l < tfsec-scan-results.txt 2>/dev/null || echo 0) lines)"
          echo "   - trivy-results.sarif ($(wc -c < trivy-results.sarif 2>/dev/null || echo 0) bytes)"
          echo "   - tfsec-results.sarif ($(wc -c < tfsec-results.sarif 2>/dev/null || echo 0) bytes)"
          echo ""
          
          # Verify SARIF files exist
          if [ -f "trivy-results.sarif" ]; then
            echo "✅ Trivy SARIF file exists and ready for publication"
          else
            echo "❌ WARNING: Trivy SARIF file not found!"
          fi
          
          if [ -f "tfsec-results.sarif" ]; then
            echo "✅ TfSec SARIF file exists and ready for publication"
          else
            echo "❌ WARNING: TfSec SARIF file not found!"
          fi
          echo ""
          
          # Only show success if we reach this point (both scans passed)
          echo ""
          echo "========================================================"
          echo "SECURITY ANALYSIS COMPLETED SUCCESSFULLY"
          echo "========================================================"
          echo ""
          echo "Scan Results:"
          echo "   - Trivy Scan: PASSED (no CRITICAL/HIGH/MEDIUM issues)"
          echo "   - TfSec Scan: PASSED (no MEDIUM+ issues)"
          echo "   - Files Analyzed: $(find . -name "*.tf" | wc -l) Terraform files"
          echo "   - Security Issues: NONE DETECTED"
          echo ""
          echo "Security Compliance:"
          echo "   - Infrastructure configurations secure"
          echo "   - Best practices followed"
          echo "   - No critical vulnerabilities found"
          echo "   - Ready for deployment"
          echo ""
          echo "Detailed scan logs saved to:"
          echo "   - trivy-scan-results.txt"
          echo "   - tfsec-scan-results.txt"
          echo "   - trivy-results.sarif (SARIF format for Scans tab)"
          echo "   - tfsec-results.sarif (SARIF format for Scans tab)"
          echo ""
          echo "SECURITY CLEARANCE GRANTED - Proceeding to manual approval"
          
          # Log successful security scan to Application Insights
          echo "Logging successful security scan to Application Insights..."
          
          # Create JSON payload for successful security scan using printf
          printf '{
            "time": "%s",
            "iKey": "%s",
            "name": "Microsoft.ApplicationInsights.Message",
            "tags": {
              "ai.cloud.roleInstance": "%s",
              "ai.operation.id": "%s",
              "ai.operation.name": "Security Scan Success"
            },
            "data": {
              "baseType": "MessageData",
              "baseData": {
                "ver": 2,
                "message": "Security Scan Completed Successfully - Deployment Approved",
                "severityLevel": "Information",
                "properties": {
                  "PipelineId": "%s",
                  "PipelineName": "%s",
                  "TeamName": "%s",
                  "ProjectName": "%s",
                  "Environment": "%s",
                  "Stage": "SecurityScan",
                  "Status": "Success",
                  "TrivyStatus": "PASSED",
                  "TfSecStatus": "PASSED",
                  "FilesAnalyzed": "%s",
                  "ModulesAnalyzed": "%s",
                  "SecurityIssues": "NONE",
                  "Branch": "%s",
                  "Commit": "%s"
                }
              }
            }
          }' \
          "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
          "$(INSTRUMENTATION_KEY)" \
          "$(Agent.MachineName)" \
          "$(Build.BuildId)" \
          "$(Build.BuildId)" \
          "$(Build.DefinitionName)" \
          "${{ parameters.teamName }}" \
          "${{ parameters.projectName }}" \
          "${{ parameters.environment }}" \
          "$(find . -name "*.tf" | wc -l)" \
          "$(find . -name "main.tf" | wc -l)" \
          "$(Build.SourceBranch)" \
          "$(Build.SourceVersion)" > security_success_log.json
          
          # Send to Application Insights
          curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
            -H "Content-Type: application/json" \
            -H "Accept: application/json" \
            -d @security_success_log.json || echo "Failed to log to Application Insights"
      continueOnError: false
    
    # Prepare SARIF files at root level for Scans tab (must be flat structure)
    - task: AzureCLI@2
      displayName: 'Stage SARIF Files for Scans Tab'
      condition: always()
      inputs:
        azureSubscription: 'sc-terraform-${{ parameters.environment }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Preparing SARIF files for Azure DevOps Scans tab..."
          echo "Creating CodeAnalysisLogs directory at artifact staging location..."
          mkdir -p $(Build.ArtifactStagingDirectory)/CodeAnalysisLogs
          
          # Change to deployment path to find SARIF files
          cd $(deploymentPath)
          
          echo "Current directory: $(pwd)"
          echo "Searching for SARIF files..."
          echo ""
          
          # Find SARIF files in current directory and subdirectories
          find . -name "*.sarif" -type f | while read -r sarif_file; do
            echo "Found SARIF file: ${sarif_file}"
            FILENAME=$(basename "${sarif_file}")
            echo "Copying ${FILENAME} to CodeAnalysisLogs..."
            cp "${sarif_file}" $(Build.ArtifactStagingDirectory)/CodeAnalysisLogs/ || echo "Warning: Failed to copy ${FILENAME}"
          done
          
          # Also check common locations
          for sarif_file in "trivy-results.sarif" "tfsec-results.sarif" "./trivy-results.sarif" "./tfsec-results.sarif"; do
            if [ -f "${sarif_file}" ]; then
              FILENAME=$(basename "${sarif_file}")
              echo "Found ${FILENAME} - copying to CodeAnalysisLogs..."
              cp "${sarif_file}" $(Build.ArtifactStagingDirectory)/CodeAnalysisLogs/ || echo "Warning: Failed to copy ${FILENAME}"
            fi
          done
          
          echo ""
          echo "Verifying SARIF files in artifact staging:"
          ls -lh $(Build.ArtifactStagingDirectory)/CodeAnalysisLogs/ || echo "No SARIF files found"
          echo ""
          
          # List files that will be published
          SARIF_COUNT=$(find $(Build.ArtifactStagingDirectory)/CodeAnalysisLogs/ -name "*.sarif" -type f | wc -l)
          if [ "$SARIF_COUNT" -gt 0 ]; then
            echo "✅ Found ${SARIF_COUNT} SARIF file(s) ready for Scans tab:"
            find $(Build.ArtifactStagingDirectory)/CodeAnalysisLogs/ -name "*.sarif" -type f | while read -r file; do
              echo "   • $(basename "${file}") ($(wc -c < "${file}" || echo 0) bytes)"
            done
          else
            echo "⚠️  No SARIF files found in CodeAnalysisLogs directory"
            echo "This may prevent results from appearing in the Scans tab"
          fi
          echo ""
          echo "SARIF files ready for Scans tab ingestion"
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Security Scan Results'
      condition: always()  # Publish results even if scan fails
      inputs:
        targetPath: '$(deploymentPath)/trivy-scan-results.txt'
        artifact: 'security-scan-trivy'
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish TfSec Scan Results'
      condition: always()  # Publish results even if scan fails
      inputs:
        targetPath: '$(deploymentPath)/tfsec-scan-results.txt'
        artifact: 'security-scan-tfsec'
    
    # Publish SARIF results to Azure DevOps Scans tab for better visualization
    # CRITICAL: SARIF files MUST be at root of CodeAnalysisLogs artifact (flat structure)
    - task: PublishPipelineArtifact@1
      displayName: 'Publish SARIF Results to Scans Tab'
      condition: always()
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/CodeAnalysisLogs'
        artifact: 'CodeAnalysisLogs'
        publishLocation: 'pipeline'

- stage: ManualApproval
  displayName: 'Manual Approval for Deployment'
  dependsOn: SecurityScan
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: waitForValidation
    displayName: 'Wait for Manual Approval'
    pool: server
    timeoutInMinutes: 1440  # 24 hours timeout
    steps:
    - task: ManualValidation@0
      displayName: 'Review and Approve Deployment'
      inputs:
        notifyUsers: |
          # Add email addresses of approvers here
          # user1@company.com
          # user2@company.com
        instructions: |
          Please review the Terraform plan and approve deployment to ${{ parameters.environment }} environment.
          
          DEPLOYMENT DETAILS:
          - Team: ${{ parameters.teamName }}
          - Project: ${{ parameters.projectName }}
          - Environment: ${{ parameters.environment }}
          
          REVIEW ARTIFACTS:
          - Download 'terraform-plan-readable' for infrastructure details
          - Download 'security-scan-trivy' for detailed security analysis
          - Download 'security-scan-tfsec' for compliance scan results
          
          SECURITY ANALYSIS RESULTS:
          Infrastructure security scans have PASSED
          
          What was scanned:
          - Trivy: Infrastructure misconfigurations, vulnerabilities, compliance
          - TfSec: Cloud provider security best practices, resource configurations
          - Coverage: All Terraform files and module dependencies
          
          RESOURCES TO BE CREATED:
          Review the Plan stage output for Azure resources:
          - Resource Group
          - Storage Account  
          - Key Vault (with security configurations validated)
          - Function App (with proper authentication settings)
          - Application Insights
          - Log Analytics Workspace
          - Service Bus (with secure configurations)
          
          COST ESTIMATE:
          Review the infrastructure plan for resource costs:
          - Consumption-based pricing for most services
          - Estimated monthly range: $25-200 depending on usage
          
          PRE-APPROVAL CHECKLIST:
          [x] Security scans passed (Trivy + TfSec)
          [x] Infrastructure plan reviewed
          [x] Resource configurations validated
          [x] Cost impact acceptable
          
          🔍 For precise costs:
          1. Check the Plan stage output above
          2. Use Azure Pricing Calculator
          3. Set up cost alerts after deployment
          
          🔒 **Security Status:**
          - Security scan must PASS before approval
          - Review any security findings in previous stage
          
          ✅ **Approve** if plan and costs are acceptable
          ❌ **Reject** if changes are needed

- stage: Deploy
  displayName: 'Deploy Infrastructure'
  dependsOn: ManualApproval
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: TerraformApply
    displayName: 'Deploy to ${{ parameters.environment }}'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
    - checkout: BBA-Infra-Terraform
    - download: current
      artifact: terraform-plan
    
    - script: |
        echo "Installing Terraform for deployment..."
        
        # Download Terraform with error handling
        if ! curl -fsSL https://releases.hashicorp.com/terraform/1.13.3/terraform_1.13.3_linux_amd64.zip -o terraform.zip; then
          echo "❌ Failed to download Terraform"
          
          # Log Terraform download failure to Application Insights
          echo "Logging Terraform download failure to Application Insights..."
          
          # Create JSON payload for Terraform download failure using printf
          printf '{
            "time": "%s",
            "iKey": "%s",
            "name": "Microsoft.ApplicationInsights.Message",
            "tags": {
              "ai.cloud.roleInstance": "%s",
              "ai.operation.id": "%s",
              "ai.operation.name": "Terraform Download Failure"
            },
            "data": {
              "baseType": "MessageData",
              "baseData": {
                "ver": 2,
                "message": "Failed to download Terraform during deployment preparation",
                "severityLevel": "Critical",
                "properties": {
                  "team": "%s",
                  "project": "%s",
                  "environment": "%s",
                  "stage": "Deploy",
                  "operation": "terraform download",
                  "buildId": "%s",
                  "buildNumber": "%s",
                  "sourceBranch": "%s",
                  "sourceVersion": "%s",
                  "agentName": "%s",
                  "errorType": "TerraformDownloadFailure",
                  "timestamp": "%s"
                }
              }
            }
          }' \
          "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
          "$(INSTRUMENTATION_KEY)" \
          "$(Agent.MachineName)" \
          "$(Build.BuildId)" \
          "${{ parameters.teamName }}" \
          "${{ parameters.projectName }}" \
          "${{ parameters.environment }}" \
          "$(Build.BuildId)" \
          "$(Build.BuildNumber)" \
          "$(Build.SourceBranch)" \
          "$(Build.SourceVersion)" \
          "$(Agent.Name)" \
          "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > terraform_download_failure_log.json
          
          # Send log to Application Insights
          curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
            -H "Content-Type: application/json" \
            -d @terraform_download_failure_log.json || echo "Failed to send log to Application Insights"
          
          exit 1
        fi
        
        # Extract and install Terraform with error handling
        if ! unzip terraform.zip || ! sudo mv terraform /usr/local/bin/; then
          echo "❌ Failed to install Terraform"
          
          # Log Terraform installation failure to Application Insights
          echo "Logging Terraform installation failure to Application Insights..."
          
          # Create JSON payload for Terraform installation failure using printf
          printf '{
            "time": "%s",
            "iKey": "%s",
            "name": "Microsoft.ApplicationInsights.Message",
            "tags": {
              "ai.cloud.roleInstance": "%s",
              "ai.operation.id": "%s",
              "ai.operation.name": "Terraform Install Failure"
            },
            "data": {
              "baseType": "MessageData",
              "baseData": {
                "ver": 2,
                "message": "Failed to install Terraform during deployment preparation",
                "severityLevel": "Critical",
                "properties": {
                  "team": "%s",
                  "project": "%s",
                  "environment": "%s",
                  "stage": "Deploy",
                  "operation": "terraform install",
                  "buildId": "%s",
                  "buildNumber": "%s",
                  "sourceBranch": "%s",
                  "sourceVersion": "%s",
                  "agentName": "%s",
                  "errorType": "TerraformInstallFailure",
                  "timestamp": "%s"
                }
              }
            }
          }' \
          "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
          "$(INSTRUMENTATION_KEY)" \
          "$(Agent.MachineName)" \
          "$(Build.BuildId)" \
          "${{ parameters.teamName }}" \
          "${{ parameters.projectName }}" \
          "${{ parameters.environment }}" \
          "$(Build.BuildId)" \
          "$(Build.BuildNumber)" \
          "$(Build.SourceBranch)" \
          "$(Build.SourceVersion)" \
          "$(Agent.Name)" \
          "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > terraform_install_failure_log.json
          
          # Send log to Application Insights
          curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
            -H "Content-Type: application/json" \
            -d @terraform_install_failure_log.json || echo "Failed to send log to Application Insights"
          
          exit 1
        fi
        
        # Verify Terraform installation
        terraform version
      displayName: 'Install Terraform'
    
    - task: AzureCLI@2
      displayName: 'Terraform Apply'
      inputs:
        azureSubscription: 'sc-terraform-${{ parameters.environment }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        addSpnToEnvironment: true
        inlineScript: |
          echo "Deploying ${{ parameters.teamName }}/${{ parameters.projectName }} to ${{ parameters.environment }}"
          
          # Set up Azure subscription context for Terraform
          echo "Setting up Azure subscription context..."
          export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
          export ARM_CLIENT_ID=$servicePrincipalId
          export ARM_CLIENT_SECRET=$servicePrincipalKey
          export ARM_TENANT_ID=$tenantId
          echo "Using subscription: $ARM_SUBSCRIPTION_ID"
          
          cd $(deploymentPath)
          
          # Copy plan from artifacts
          cp $(Pipeline.Workspace)/terraform-plan/tfplan .
          
          # Initialize Terraform
          echo "Initializing Terraform for deployment..."
          if ! terraform init; then
            echo "❌ Terraform init failed during deployment"
            
            # Log terraform init failure during deployment to Application Insights
            echo "Logging deployment terraform init failure to Application Insights..."
            
            # Create JSON payload for deployment terraform init failure
            {
              echo "{"
              echo "  \"time\": \"$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)\","
              echo "  \"iKey\": \"$(INSTRUMENTATION_KEY)\","
              echo "  \"name\": \"Microsoft.ApplicationInsights.Message\","
              echo "  \"tags\": {"
              echo "    \"ai.cloud.roleInstance\": \"$(Agent.MachineName)\","
              echo "    \"ai.operation.id\": \"$(Build.BuildId)\","
              echo "    \"ai.operation.name\": \"Deploy Terraform Init Failure\""
              echo "  },"
              echo "  \"data\": {"
              echo "    \"baseType\": \"MessageData\","
              echo "    \"baseData\": {"
              echo "      \"ver\": 2,"
              echo "      \"message\": \"Terraform initialization failed during infrastructure deployment\","
              echo "      \"severityLevel\": \"Critical\","
              echo "      \"properties\": {"
              echo "        \"team\": \"${{ parameters.teamName }}\","
              echo "        \"project\": \"${{ parameters.projectName }}\","
              echo "        \"environment\": \"${{ parameters.environment }}\","
              echo "        \"stage\": \"Deploy\","
              echo "        \"operation\": \"terraform init\","
              echo "        \"buildId\": \"$(Build.BuildId)\","
              echo "        \"buildNumber\": \"$(Build.BuildNumber)\","
              echo "        \"sourceBranch\": \"$(Build.SourceBranch)\","
              echo "        \"sourceVersion\": \"$(Build.SourceVersion)\","
              echo "        \"agentName\": \"$(Agent.Name)\","
              echo "        \"deploymentPath\": \"$(deploymentPath)\","
              echo "        \"errorType\": \"DeploymentTerraformInitFailure\","
              echo "        \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\""
              echo "      }"
              echo "    }"
              echo "  }"
              echo "}"
            } > deploy_terraform_init_failure_log.json
            
            # Send log to Application Insights
            curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
              -H "Content-Type: application/json" \
              -d @deploy_terraform_init_failure_log.json || echo "Failed to send log to Application Insights"
            
            exit 1
          fi
          
          # Apply the plan
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "                    🚀 STARTING INFRASTRUCTURE DEPLOYMENT                      "
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "  Environment: ${{ parameters.environment }}"
          echo "  Team: ${{ parameters.teamName }}"
          echo "  Project: ${{ parameters.projectName }}"
          echo "  Deployment Path: $(deploymentPath)"
          echo ""
          echo "  Applying Terraform plan..."
          echo ""
          
          APPLY_OUTPUT=$(terraform apply -auto-approve tfplan 2>&1)
          APPLY_EXIT_CODE=$?
          
          # Check if error is about existing dashboard that needs import
          if [ $APPLY_EXIT_CODE -ne 0 ] && echo "$APPLY_OUTPUT" | grep -q "already exists.*azurerm_portal_dashboard"; then
            echo "⚠️  Dashboard already exists in Azure. Attempting to import into Terraform state..."
            
            # Extract dashboard ID directly from the error message (the exact format from Terraform error)
            EXTRACTED_ID=$(echo "$APPLY_OUTPUT" | grep -oE '/subscriptions/[a-f0-9-]+/resourceGroups/[^/]+/providers/Microsoft\.Portal/dashboards/[^"]+' | head -1)
            
            if [ -z "$EXTRACTED_ID" ]; then
              echo "⚠️  Could not extract dashboard ID from error message"
              echo "Error output:"
              echo "$APPLY_OUTPUT" | grep -A 5 "already exists"
              echo "Please manually import the dashboard or check the exact resource ID"
              exit 1
            fi
            
            echo "Extracted dashboard ID from error: ${EXTRACTED_ID}"
            
            # Extract module name from error output - it will be like: module.loan_origination_dev
            # Try to extract from error message first
            MODULE_NAME=$(echo "$APPLY_OUTPUT" | grep -oP "module\.\w+\.azurerm_portal_dashboard" | head -1 | sed 's/\.azurerm_portal_dashboard//')
            
            if [ -z "$MODULE_NAME" ]; then
              # Fallback: Construct module name from parameters
              # Module names follow pattern: loan_{projectName}_{environment}
              # Example: loan-origination -> loan_origination_dev
              PROJECT_NAME_UNDERSCORE=$(echo "${{ parameters.projectName }}" | tr '-' '_')
              MODULE_NAME="module.loan_${PROJECT_NAME_UNDERSCORE}_${{ parameters.environment }}"
              echo "Using constructed module name: ${MODULE_NAME}"
            else
              echo "Found module name in error output: ${MODULE_NAME}"
            fi
            
            IMPORT_PATH="${MODULE_NAME}.azurerm_portal_dashboard.main[0]"
            echo "Importing dashboard: ${IMPORT_PATH} -> ${EXTRACTED_ID}"
            
            # Import the existing dashboard into Terraform state
            echo "Importing dashboard into Terraform state..."
            terraform import "${IMPORT_PATH}" "${EXTRACTED_ID}"
            
            if [ $? -eq 0 ]; then
              echo "✅ Dashboard successfully imported into Terraform state"
            else
              echo "❌ Dashboard import failed. Please check the resource ID and module path."
              exit 1
            fi
            
            # After import, the saved plan is stale - need to create a new plan
            echo "Creating a new plan after dashboard import (state has changed)..."
            terraform plan -out=tfplan-new.tfplan
            
            if [ $? -eq 0 ]; then
              echo "Retrying Terraform apply with new plan..."
              APPLY_OUTPUT=$(terraform apply -auto-approve tfplan-new.tfplan 2>&1)
              APPLY_EXIT_CODE=$?
            else
              echo "❌ Failed to create new plan after import"
              APPLY_EXIT_CODE=1
            fi
          fi
          
          if [ $APPLY_EXIT_CODE -eq 0 ]; then
            # Parse successful deployment output
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "                    ✅ DEPLOYMENT SUCCESSFUL                                    "
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            
            # Extract resource information from apply output
            echo "  📊 Deployment Summary:"
            echo "  ┌──────────────────────────────────────────────────────────────────────────────────────────────┐"
            printf "  │ %-30s │ %-75s │\n" "STATUS" "MESSAGE"
            echo "  ├──────────────────────────────────────────────────────────────────────────────────────────────┤"
            printf "  │ %-30s │ %-75s │\n" "✅ Deployment Status" "Successfully completed"
            printf "  │ %-30s │ %-75s │\n" "📍 Environment" "${{ parameters.environment }}"
            printf "  │ %-30s │ %-75s │\n" "👥 Team" "${{ parameters.teamName }}"
            printf "  │ %-30s │ %-75s │\n" "📦 Project" "${{ parameters.projectName }}"
            echo "  └──────────────────────────────────────────────────────────────────────────────────────────────┘"
            echo ""
            
            # Count resources from state
            RESOURCE_COUNT=$(terraform state list 2>/dev/null | wc -l || echo "0")
            echo "  📈 Infrastructure Statistics:"
            echo "  ┌──────────────────────────────────────────────────────┐"
            printf "  │ %-50s │\n" "Total Resources Managed: $RESOURCE_COUNT"
            echo "  └──────────────────────────────────────────────────────┘"
            echo ""
            
            # Show recently created/updated resources
            echo "  🎯 Resources in State:"
            echo "  ┌──────────────────────────────────────────────────────────────────────────────────────────────────────┐"
            printf "  │ %-40s │ %-70s │\n" "RESOURCE TYPE" "RESOURCE ADDRESS"
            echo "  ├──────────────────────────────────────────────────────────────────────────────────────────────────────┤"
            terraform state list 2>/dev/null | head -20 | while read -r resource; do
              TYPE=$(echo "$resource" | sed 's/.*\.\([^[.]*\)\[.*/\1/' | sed 's/.*\.\([^[.]*\)$/\1/')
              TYPE_SHORT=$(echo "$TYPE" | sed 's/^azurerm_//' | sed 's/_/ /g' | awk '{for(i=1;i<=NF;i++)sub(/./,toupper(substr($i,1,1)),$i)}1')
              printf "  │ %-40s │ %-70s │\n" "$TYPE_SHORT" "$resource"
            done
            if [ "$RESOURCE_COUNT" -gt 20 ]; then
              printf "  │ %-40s │ %-70s │\n" "..." "And $((RESOURCE_COUNT - 20)) more resources"
            fi
            echo "  └──────────────────────────────────────────────────────────────────────────────────────────────────────┘"
            echo ""
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "  ✅ Infrastructure deployment completed successfully!"
            echo "  📝 Next steps: Review the infrastructure in Azure Portal"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
          else
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "                    ❌ DEPLOYMENT FAILED                                        "
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            echo "  ❌ Terraform apply failed - Deployment unsuccessful"
            echo ""
            echo "  Error Details:"
            echo "  ┌──────────────────────────────────────────────────────────────────────────────────────────────────────┐"
            echo "$APPLY_OUTPUT" | grep -E "Error|error|failed|Failed" | head -10 | while read -r line; do
              printf "  │ %-110s │\n" "$(echo "$line" | cut -c1-110)"
            done
            echo "  └──────────────────────────────────────────────────────────────────────────────────────────────────────┘"
            echo ""
            echo "  Full error output saved for review."
            
            # Log terraform apply failure to Application Insights
            echo "Logging terraform apply failure to Application Insights..."
            
            # Create JSON payload for terraform apply failure
            {
              echo "{"
              echo "  \"time\": \"$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)\","
              echo "  \"iKey\": \"$(INSTRUMENTATION_KEY)\","
              echo "  \"name\": \"Microsoft.ApplicationInsights.Message\","
              echo "  \"tags\": {"
              echo "    \"ai.cloud.roleInstance\": \"$(Agent.MachineName)\","
              echo "    \"ai.operation.id\": \"$(Build.BuildId)\","
              echo "    \"ai.operation.name\": \"Terraform Apply Failure\""
              echo "  },"
              echo "  \"data\": {"
              echo "    \"baseType\": \"MessageData\","
              echo "    \"baseData\": {"
              echo "      \"ver\": 2,"
              echo "      \"message\": \"Terraform apply failed - Infrastructure deployment unsuccessful\","
              echo "      \"severityLevel\": \"Critical\","
              echo "      \"properties\": {"
              echo "        \"team\": \"${{ parameters.teamName }}\","
              echo "        \"project\": \"${{ parameters.projectName }}\","
              echo "        \"environment\": \"${{ parameters.environment }}\","
              echo "        \"stage\": \"Deploy\","
              echo "        \"operation\": \"terraform apply\","
              echo "        \"buildId\": \"$(Build.BuildId)\","
              echo "        \"buildNumber\": \"$(Build.BuildNumber)\","
              echo "        \"sourceBranch\": \"$(Build.SourceBranch)\","
              echo "        \"sourceVersion\": \"$(Build.SourceVersion)\","
              echo "        \"agentName\": \"$(Agent.Name)\","
              echo "        \"deploymentPath\": \"$(deploymentPath)\","
              echo "        \"errorType\": \"TerraformApplyFailure\","
              echo "        \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\""
              echo "      }"
              echo "    }"
              echo "  }"
              echo "}"
            } > terraform_apply_failure_log.json
            
            # Send log to Application Insights
            curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
              -H "Content-Type: application/json" \
              -d @terraform_apply_failure_log.json || echo "Failed to send log to Application Insights"
            
            exit 1
          fi
          
          # Log successful deployment to Application Insights
          echo "Logging successful deployment to Application Insights..."
          
          # Create JSON payload for successful deployment
          {
            echo "{"
            echo "  \"time\": \"$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)\","
            echo "  \"iKey\": \"$(INSTRUMENTATION_KEY)\","
            echo "  \"name\": \"Microsoft.ApplicationInsights.Message\","
            echo "  \"tags\": {"
            echo "    \"ai.cloud.roleInstance\": \"$(Agent.MachineName)\","
            echo "    \"ai.operation.id\": \"$(Build.BuildId)\","
            echo "    \"ai.operation.name\": \"Deployment Success\""
            echo "  },"
            echo "  \"data\": {"
            echo "    \"baseType\": \"MessageData\","
            echo "    \"baseData\": {"
            echo "      \"ver\": 2,"
            echo "      \"message\": \"Infrastructure deployment completed successfully\","
            echo "      \"severityLevel\": \"Information\","
            echo "      \"properties\": {"
            echo "        \"team\": \"${{ parameters.teamName }}\","
            echo "        \"project\": \"${{ parameters.projectName }}\","
            echo "        \"environment\": \"${{ parameters.environment }}\","
            echo "        \"stage\": \"Deploy\","
            echo "        \"operation\": \"terraform apply\","
            echo "        \"buildId\": \"$(Build.BuildId)\","
            echo "        \"buildNumber\": \"$(Build.BuildNumber)\","
            echo "        \"sourceBranch\": \"$(Build.SourceBranch)\","
            echo "        \"sourceVersion\": \"$(Build.SourceVersion)\","
            echo "        \"agentName\": \"$(Agent.Name)\","
            echo "        \"deploymentPath\": \"$(deploymentPath)\","
            echo "        \"status\": \"Success\","
            echo "        \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\""
            echo "      }"
            echo "    }"
            echo "  }"
            echo "}"
          } > terraform_apply_success_log.json
          
          # Send log to Application Insights
          curl -X POST "https://dc.applicationinsights.azure.com/v2/track" \
            -H "Content-Type: application/json" \
            -d @terraform_apply_success_log.json || echo "Failed to send log to Application Insights"

- stage: PostDeployValidation
  displayName: 'Post-Deployment Validation'
  dependsOn: Deploy
  jobs:
  - job: ValidateDeployment
    displayName: 'Validate Deployed Resources'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
    - checkout: BBA-Infra-Terraform
    - script: |
        curl -fsSL https://releases.hashicorp.com/terraform/1.13.3/terraform_1.13.3_linux_amd64.zip -o terraform.zip
        unzip terraform.zip
        sudo mv terraform /usr/local/bin/
        terraform version
      displayName: 'Install Terraform'
    
    - task: AzureCLI@2
      displayName: 'Validate Infrastructure State'
      inputs:
        azureSubscription: 'sc-terraform-${{ parameters.environment }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        addSpnToEnvironment: true
        inlineScript: |
          echo "Validating deployment for ${{ parameters.teamName }}-${{ parameters.projectName }}-${{ parameters.environment }}"
          
          # Set up Azure subscription context for Terraform
          echo "Setting up Azure subscription context..."
          export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
          export ARM_CLIENT_ID=$servicePrincipalId
          export ARM_CLIENT_SECRET=$servicePrincipalKey
          export ARM_TENANT_ID=$tenantId
          echo "Using subscription: $ARM_SUBSCRIPTION_ID"
          
          cd $(deploymentPath)
          
          # Initialize Terraform
          terraform init
          
          # Check state consistency
          echo "Checking Terraform state consistency..."
          terraform plan -detailed-exitcode
          if [ $? -eq 0 ]; then
            echo "✅ Infrastructure state is consistent - no drift detected"
          elif [ $? -eq 2 ]; then
            echo "⚠️  Infrastructure drift detected - manual review required"
            exit 1
          else
            echo "❌ Terraform plan failed"
            exit 1
          fi
          
    - task: AzureCLI@2
      displayName: 'Validate Azure Resources'
      inputs:
        azureSubscription: 'sc-terraform-${{ parameters.environment }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        addSpnToEnvironment: true
        inlineScript: |
          echo "Validating Azure resources for ${{ parameters.teamName }}-${{ parameters.projectName }}-${{ parameters.environment }}"
          
          # Set up Azure subscription context
          echo "Setting up Azure subscription context..."
          export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
          export ARM_CLIENT_ID=$servicePrincipalId
          export ARM_CLIENT_SECRET=$servicePrincipalKey
          export ARM_TENANT_ID=$tenantId
          echo "Using subscription: $ARM_SUBSCRIPTION_ID"
          
          # Check resource group
          RG_NAME="rg-${{ parameters.teamName }}-${{ parameters.projectName }}-${{ parameters.environment }}"
          echo "Checking Resource Group: $RG_NAME"
          az group show --name $RG_NAME --output table || echo "Resource group not found"
          
          # List resources in the group
          echo "Resources in group:"
          az resource list --resource-group $RG_NAME --output table || echo "No resources found"
          
          echo "✅ Post-deployment validation completed!"